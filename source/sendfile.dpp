import udtwrap;

import std.conv : to;
import std.stdio : writeln, writefln;
import std.socket:AddressInfoFlags,AddressFamily,SocketType;
import std.string : toStringz, fromStringz;
import std.exception : enforce;

struct addrinfo
{
  int ai_flags;                 /* Input flags.  */
  int ai_family;                /* Protocol family for socket.  */
  int ai_socktype;              /* Socket type.  */
  int ai_protocol;              /* Protocol for socket.  */
  socklen_t ai_addrlen;         /* Length of socket address.  */
  sockaddr *ai_addr;     /* Socket address for socket.  */
  char *ai_canonname;           /* Canonical name for service location.  */
  addrinfo *ai_next;     /* Pointer to next in list.  */
}

extern (C) int getaddrinfo (const char *name,
                        const char *service,
                        const addrinfo *req,
                        addrinfo **pai);
extern (C) void freeaddrinfo (addrinfo *__ai);

int main(string[] args) {
	//usage: sendfile [server_port]
	if(args.length>2 || (args.length==2 && args[0].to!int <= 0)) {
		writeln("usage: sendfile [server_port]");
		return 0;
	}
	
	addrinfo hints;
	addrinfo* res;

	hints.ai_flags = AddressInfoFlags.PASSIVE.to!int;
	hints.ai_family = AddressFamily.INET.to!int;
	hints.ai_socktype = SocketType.STREAM.to!int;

	string service="9000";
	if(args.length == 2) {
	   	service = args[1];
	}

	if(0 != getaddrinfo(null, service.toStringz(), &hints, &res)) {
	   	writeln("illegal port number or port is busy.");
	   	return -1;
	}

	writeln("Before UdtSocket create");
	auto serv = UdtSocket.create(res.ai_family.to!AddressFamily,
			to!SocketType(res.ai_socktype), res.ai_protocol);
	writeln("After UdtSocket create");
	writeln("Before SocketAddress bind");
	auto aiAddr = SocketAddress(*res.ai_addr);
	serv.bind(aiAddr);
	writeln("After SocketAddress bind");

	freeaddrinfo(res);

	writeln("Before serv.listen");
	serv.listen(10);
	writeln("After serv.listen");

	SocketAddressStorage clientAddr;
	UdtSocket fhandle;

	while (true) {
		import std.concurrency:spawn;
		writeln("Before serv.accept");
		serv.accept(fhandle, clientAddr);
		writeln("After serv.accept");
		clientAddr.getNameInfo();
		writefln!"new connection: %s:%s"(clientAddr.clientHost, clientAddr.clientService);
		writeln("Before spawn");
		spawn(&sendfile, cast(shared)&fhandle);
		writeln("After spawn");
	}

	serv.close();

	return 0;
}

void sendfile(shared(UdtSocket)* usocket) {
	import std.file : getSize;
	import std.string : fromStringz;
	import std.exception : assumeUnique;

	UdtSocket fhandle = *cast()usocket;

	char[1024] file;
	int len;

	writeln("    Before len receive");
	fhandle.receive((cast(ubyte*)&len)[0 .. int.sizeof]);
	writeln("    After len receive");
	enforce(len >= 0 && len < file.length, "the length of the expected filename exceeds " ~
		"the size of the buffer the filename is supposed to be stored in");

	writeln("    Before file receive");
	fhandle.receive(cast(ubyte[])file);
	writeln("    After file receive");
	file[len] = '\0';

	ulong size = getSize(file[0 .. len]);

	// send file size information
	writeln("    Before size send");
	fhandle.send(size);
	writeln("    After size send");

	TraceInfo trace;
	trace = fhandle.perfMon(trace);

	writeln("    Before file send");
	// send the file
	long offset = 0;
	fhandle.sendFile(assumeUnique(file[0 .. len]), offset);
	writeln("    After file send");

	trace = fhandle.perfMon(trace);
	writefln("speed = %s Mbits/sec",trace.mbpsSendRate);

	fhandle.close();
}
