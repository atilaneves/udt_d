import udtwrap;
import core.thread;
import core.time;
import std.string;
import std.stdio;
import std.conv:to;
import std.socket:AddressInfoFlags,AddressFamily,SocketType;

//#include <arpa/inet.h>
//#include <sys/types.h>
//#include <sys/socket.h>
//#include <netdb.h>
#include <pthread.h>

struct addrinfo
{
  int ai_flags;                 /* Input flags.  */
  int ai_family;                /* Protocol family for socket.  */
  int ai_socktype;              /* Socket type.  */
  int ai_protocol;              /* Protocol for socket.  */
  socklen_t ai_addrlen;         /* Length of socket address.  */
  sockaddr *ai_addr;     /* Socket address for socket.  */
  char *ai_canonname;           /* Canonical name for service location.  */
  addrinfo *ai_next;     /* Pointer to next in list.  */
}

extern (C) int getaddrinfo (const char *name,
                        const char *service,
                        const addrinfo *req,
                        addrinfo **pai);
/* Free `addrinfo' structure AI including associated storage.  */
extern (C) void freeaddrinfo (addrinfo *__ai);
extern (C) int getnameinfo (const sockaddr *sa,
                        socklen_t __salen, char *host,
                        socklen_t __hostlen, char *serv,
                        socklen_t __servlen, int __flags);

enum NI_MAXHOST=200;
enum NI_MAXSERV = 200;


int main(string[] args)
{
	if ((args.length!=1) || (args.length==2 && args[1].isNumeric))
	{
		stderr.writeln("usage: appserver [server_port]");
		return 0;
	}

	addrinfo hints;
	addrinfo* res;

	hints.ai_flags = AddressInfoFlags.PASSIVE.to!int;
	hints.ai_family = AddressFamily.INET.to!int;
	hints.ai_socktype = SocketType.STREAM; // DGRAM

	string service = (args.length == 2) ? args[1] : "9000";

	if (0 != getaddrinfo(null, service.toStringz, &hints, &res))
	{
		writefln("illegal port number or port is busy.");
		return 0;
	}

	auto serv = UdtSocket.create(res.ai_family.to!AddressFamily, SocketType.STREAM, res.ai_protocol);

	// UDT Options
	//UDT::setsockopt(serv, 0, UDT_CC, new CCCFactory<CUDPBlast>, sizeof(CCCFactory<CUDPBlast>));
	//UDT::setsockopt(serv, 0, UDT_MSS, new int(9000), sizeof(int));
	//UDT::setsockopt(serv, 0, UDT_RCVBUF, new int(10000000), sizeof(int));
	//UDT::setsockopt(serv, 0, UDP_RCVBUF, new int(10000000), sizeof(int));

	auto aiAddr = SocketAddress(*res.ai_addr);
	serv.bind(aiAddr);

	freeaddrinfo(res);

	writefln("server is ready at port: %s" ,service);
	serv.listen(10);

	sockaddr_storage clientaddr;

	import std.concurrency:spawn;
	while (true)
	{
		auto clientAddr = SocketAddress(*cast(sockaddr*)&clientaddr);
		serv.accept(aiAddr);
		char[NI_MAXHOST]  clienthost;
		char[NI_MAXSERV]  clientservice;
		getnameinfo(cast(sockaddr *)&clientaddr, clientaddr.sizeof.to!int, clienthost.ptr, clienthost.length.to!int, clientservice.ptr, clientservice.length.to!int, AddressInfoFlags.NUMERICHOST); // | AddressInfoFlags.NUMERICSERV);
		writefln("new connection: %s:%s" ,clienthost.ptr.fromStringz,clientservice.ptr.fromStringz);

		spawn(&recvData,cast(immutable)&serv);
	}

	serv.close();
	return 0;
}

void recvData(immutable(UdtSocket)* usocket)
{
	auto recver = UdtSocket((*usocket).handle);
	ubyte[100000] data;
	auto len = recver.receive(data[],0);
	writeln("received message of %s",len);
/+
	while (true)
	{
		int rsize = 0;
		int rs;
		while (rsize < data.length)
		{
			//recver.options.udtReceiverBufferSize(int.sizeof.to!int);
			auto slice = data[rsize..$];
			rs = recver.receive(slice, 0);
			rsize += rs;
		}

		if (rsize < data.length)
			break;
	} +/
	recver.close();
}
